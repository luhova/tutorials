---
layout: default
title: Rails Girls приложение със Sinatra
permalink: sinatra-app-bg
---

# Уеб сайт с Ruby и Sinatra в Nitrous.io

*Базирано на [това ръководство](http://guides.railsgirls.com/sinatra-app/) от Piotr Szotkowski ([@chastell](https://twitter.com/chastell)). [Код на ръководството в GitHub](https://github.com/rails-girls-sofia/tutorials/blob/gh-pages/_posts/2015-08-16-sinatra-app-tutorial-in-bulgarian.markdown).*

Ръководството по-долу прави предположението, че имате регистрация в [Nitrous.io](https://nitrous.io).

## Запознаване с инструментите

Преди да започнем да правим каквото и да е, трябва да се запознаем с инструментите, които ще използваме. В нашия случай, това са обикновен текстов редактор (например Notepad) и интегрираната онлайн среда за разработка [Nitrous](https://nitrous.io).

> **Инструктор:**
>
> Обяснете разликата между обикновен текстов файл и Word документ. Влезте с участничките в Nitrous и разяснете основните компоненти там, без да навлизате в твърде много детайли – къде стоят файловете, къде е този сървър. За command line ще стане дума по-късно.

## In HTML we trust - статичен сайт

HTML е основният градивен блок на сайтовете. Преди да се занимаем с това приложение, ще покрием основни понятия в HTML и CSS с помощта на вашия инструктор.

Създайте семпла страничка, която да играе ролята на ваша визитка, като следвате напътствията на инструктора. Може да видите [една примерна такава тук](http://railsgirls.hno3.org/dimitar). Знаете ли, че можете да разгледате HTML и CSS кода на всеки сайт? Питайте вашия инструктор как.

**Бонус ниво**, ако ви остане време тук, или в края на събитието. Направете си безплатен профил в [GitHub](https://github.com) и използвайте [това ръководство](https://pages.github.com/), за да публикувате току-що създадения си сайт-визитка онлайн, на безплатния хостинг на GitHub за статични страници. Ако потребителското ви име е radostina, то сайтът ви трябва да се намира на адрес [https://radostina.github.io](https://radostina.github.io).

## Основи на програмирането с Ruby

Ще изпробваме някои неща с Ruby, като използваме инструмента `irb` (съкратено от "Interactive Ruby").

`irb` е името на програма, която идва инсталирана заедно с Ruby. Тя е вид REPL (read-eval-print loop). Може да я стартирате директно от терминала в Nutrous. Тя на свой ред наподобява command line – пишете Ruby изрази, натискате Enter и `irb` ги оценява веднага и ви показва резултата (или грешката, ако има такава).

> **Инструктор:**
>
> Разкажете накратко какво е command line (почти-синоними: терминал/конзола). Споменете, че първият интерфейс към компютрите е бил такъв. Отбележете какви предимства има това над интеракцията с програми през графичен интерфейс. Обяснете основните концепции на командния ред: `команда параметри разделени с интервали`, какво е `$` (command prompt) и как да разберем кога нещо работи и е заело командния ред, и кога процесът е приключил и можем да пишем нови команди. Как да спрем работещ процес – `ctrl-c` когато фокусът е върху командния ред.
>
> Внимание: ако в `irb` има синтактична грешка от типа на незатворена кавичка или скоба и се натисне Enter, `irb` няма да изпълни израза и да покаже грешка, а ще чака да "завършите" израза, т.е. да затворите кавичката или скобата. Prompt-ът на `irb` също ще се промени на символа, който се очаква в момента. Ето пример:
>
>     $ irb
>     irb(main):001:0> puts "Hello, world!
>     irb(main):002:0"
>     irb(main):003:0"
>
> В такива случаи, може да се натисне `ctrl-d`, `ctrl-c`, или просто да се въведе липсващият символ.

За да стартирате `irb`, напишете следната команда в конзолата на Nitrous и натиснете Enter:

    irb

Обърнете внимание, че prompt-ът (символите отляво на курсора) ще се сменят с такива от `irb`. За да ви е по-удобно, може да увеличите размера на панела с конзолата.

От `irb` се излиза с `ctrl-d` или като напишете `exit` и натиснете Enter.

### Данни и код

Програмите боравят с данни. Тези данни трябва да се вземат отнякъде. Или ги зареждате по някакъв начин от външния свят (прочитате от файл, сваляте от интернет, потребител ги попълва), или вие като програмист ги слагате директно в кода.

Данните биват различни типове:

- Текст, още наричан (текстов) низ – нещо, заградено в единични или двойни кавички: `'some text'`, `"more text here"`, ...
- Числа – цели или с плаваща запетая: `5`, `42`, `3.14`, ...
- Съставни типове данни – списъци, речници: `["apple", "orange", "pear", "melon"]`, ...
- Наши собствени типове данни – продукт, поръчка, потребител, ...

Причината за разграничаването на типовете на данните е, че с всеки тип данни могат да се правят различни операции – например, числата могат да се умножават, текстът – не.

> **Инструктор:**
>
> Упражнете основните типове данни и някои операции с тях в `irb`. Съставете списък, намерете му дължината, обходете елементите и ги отпечатайте на екрана. Обърнете внимание на разделението между данни и код.

### Имена (променливи)

Ако определени данни ни трябват на повече от едно място в програмата (което е по-честият случай), не е практично да повтаряме вмъкването им всеки път.

Затова в Ruby (и другите езици за програмиране) имаме възможност да дадем име на определени данни. Това име се нарича "променлива" и как се казва променливата си избираме ние. Добре е името да описва ясно смисъла и целта на данните, към които сочи. Насочваме името към данни, като използваме конструкцията `име = данни`. Например:

{% highlight ruby %}
participant_name = "Весела Радостинова"
{% endhighlight %}

Името `participant_name` става налично веднага след този ред код (но не и преди това). След това, правим манипулации над самото име, като реално ще работим с данните, към които името сочи. Например:

{% highlight ruby %}
puts participant_name
{% endhighlight %}

Тук `puts` е вградена в Ruby ключова дума, която извежда на екрана подадените ѝ данни.

Обърнете внимание, че имената в Ruby са просто имена. Може да насочите повече от едно име към едни и същи данни и да ги променяте от което и да е от имената. Можете и да сменяте накъде сочи дадено име. Например:

{% highlight ruby %}
participant_name = "Весела Радостинова"
puts participant_name

participant_name = 42
puts participant_name
{% endhighlight %}

Друг интересен момент е, че данните от дясната страна на равенството може да се получат в следствие на динамично изчисление, което, логично, може да включва и други, вече дефинирани променливи:

{% highlight ruby %}
instructors_count = 50
accepted_participants_count = instructors_count * 2
{% endhighlight %}

> **Инструктор:**
>
> Упражнете работа с имена и основни типове данни в `irb`. Покажете как работи повече от едно име към един и същи обект. Може да използвате метод, който променя състоянието на данните in-place, например [`String#upcase!`](http://ruby-doc.org/core-2.2.3/String.html#method-i-upcase-21). Променливите нямат тип и са просто имена/етикети, закачени към обекти.
>
> Тук е добър момент да се обърне внимание на разликата между "извеждане на екрана" (например с `puts`) и показване на резултата от даден израз, което `irb` прави автоматично след всеки израз. Добре е да се спомене и че когато Ruby програмата се изпълнява от файл (`ruby program.rb`), а не в `irb`, оценките на изразите няма да са видими, а ще се виждат само неща, които са изрично показани на екрана с `puts`.

### Действия

Както споменахме по-горе, всеки тип данни поддържа определен набор от действия върху него. Може да разглеждаме всеки тип данни в една Ruby програма като обект, над който можем да изпълняваме този набор действия. Общият начин за изпълнение на действие над определени данни е `данни.име_на_действие(опции)`. Например:

{% highlight ruby %}
"Радостина".length
6 * 7
Date.today
participants.first(5)
{% endhighlight %}

Това са все действия, дори да не виждате кръгли скоби навсякъде.Поставянето на кръгли скоби след името на действието не е задължително в Ruby.

"Каноничният" формат на записване на горния пример е такъв:

{% highlight ruby %}
"Радостина".length()
6.*(7)
Date.today()
participants.first(5)
{% endhighlight %}

Вероятно така по-лесно може да разпознаете шаблона на извикване на действие. Изпускането на кръглите скоби на места прави израза по-лесно разбираем за четящия кода. Това е една от причините да е позволено в Ruby да ги пропуснете. При изпълнение на действия над числа е позволено да се изпусне и точката, защото е по-естествено да напишем `2 + 2`, отколкото `2.+(2)`, въпреки, че първото реално се обръща вътрешно до второто.

Важно е да се отбележи, че след изпълнението на **всяко** действие има "резултат" под формата на нови данни. Тоест, всеки израз, който включва изпълнение на действие, си има резултат, който резултат представлява потенциално нови, променени данни. Тези нови данни, на свой ред, също си имат набор от действия, които може да изпълните над тях. Това е и причината да може да "навързвате" действия едно след друго:

{% highlight ruby %}
"Hello World".sub("World", "Sofia").upcase()
{% endhighlight %}

Или:

{% highlight ruby %}
Date.today.to_s
{% endhighlight %}

Обърнете внимание, че горният пример е еквивалентен на `Date.today().to_s()`.

Възможно е да наричаме данните в Ruby "обекти". Двете ще използваме като синоними – всички данни в Ruby са обекти и всички данни (обекти) си имат определен набор от валидни действия.

> **Инструктор:**
>
> Упражнете работа с действия върху обекти в `irb`.
>
> Забележка: За да ползвате `Date.today`, трябва да изпълните някъде `require 'date'`.

### Условия

Условията в езиците за програмиране ни дават възможност да напишем "умни" програми, които могат да взимат решения за промяна в логиката си по време на работа на програмата.

Това е сложен начин да опитаме да обясним следния пример:

    if условие
      изпълни това, ако условието е истина
    else
      иначе изпълни тази част
    end

Например, нека имаме този ред код:

{% highlight ruby %}
your_age = gets.to_i
{% endhighlight %}

В Ruby, `gets` е ключова дума, която пита потребителя за вход. При изпълнение на кода по-горе, Ruby програмата ви ще паузира работата си и ще очаква да въведете данни. Като ги въведете, ще ви ги върне в прогамата като текст. Ако въведете число, това число ще дойде като текст. Например, ако въведете `42`, в програмата си ще го получите като текста `"42"`. В случая, искаме да вземем годините на потребителя като число, за да можем да използваме действия, присъщи на числа. Действието `to_i` ще извлече числото от текста и ще ни го даде в подходящия тип: `"42".to_i` ще ни върне `42`.

След този ред код, можем да съставим условие, което ще промени поведението на програмата в зависимост от входа на потребителя:

{% highlight ruby %}
if your_age < 20
  puts "The future is yours!"
else
  puts "Have you seen a dinosaur?"
end
{% endhighlight %}

Условията имат и други форми. Например, `else` клонът не е задължителен. Освен това, имаме възможност да добавим и един или повече `elsif` клонове, които да позволяват разклонение на пътя на програмата на повече от две (забележете, че не е `elseif`, а е `elsif`).

**Важно:** Когато сравнявате в условия за равенство, го правите с два, а не с един символ за равенство: `==`. Помнете, че един символ `=` се ползва за присвояване на стойност на променлива, а две равенства `==` – за сравнение. За сравнение за различие, се използва `!=` (четете като "различно", или "не-равно").

> **Инструктор:**
>
> Упражнете работа с различни видове условия.

### Повторение (цикли)

За какво щеше да ни е да програмираме, ако нямахме начин да накараме компютъра да прави това, в което е най-добър – да повтори едно действие милиарди пъти за част от секундата?

Във всеки език за програмиране има начини да накараме програмата да изпълни част от логиката си определен брой пъти. Това може да е фиксиран брой (например, 10), или неограничен брой пъти, до изпълнение на дадено условие (например, повтаряй това, докато потребителят не въведе текста `"exit"`).

Повторенията се наричат още цикли.

В Ruby, както и в други езици за програмиране, има повече от един начин да се стартира един цикъл. Програмистът избира кой начин да използва според ситуацията.

Ето пример за цикъл, който ще се изпълни фиксиран брой пъти:

{% highlight ruby %}
30.times do
  puts "Hello, Ruby! I am your master now!"
end
{% endhighlight %}

Обърнете внимание, че в този пример `30` е число (данни) и всъщност `30.times` е изпълнение на действие върху тези данни. Това означава, че `30` може да се замени и с променлива и нещата пак ще работят.

Ето и пример за цикъл, който ще се повтаря неограничен брой пъти, до възникването на определено условие:

{% highlight ruby %}
correct_name = "Radostina"
name_entered = ""

while name_entered != correct_name
  if name_entered != ""
    puts "You entered " + name_entered + " but that is not the correct answer. Let's try again."
  end

  puts "Who's your master now, Ruby?"
  name_entered = gets.strip
end
{% endhighlight %}

Чувствайте се свободни да заместите "Radostina" в примера по-горе с вашето име.

> **Инструктор:**
>
> Обърнете внимание на конкатенацията на низове с `+` и на комбинацията между `if` и `while`. Обходете кода стъпка по стъпка. Упражнете цикли, в комбинация с наученото до момента.

## Динамичен сайт - за гласуване

След като сме се позабавлявали малко с HTML и CSS, е време да направим следващата важна стъпка – да напишем софтуер, който да създава HTML код вместо нас – и динамично.

Ще създадем малко приложение за гласуване.

Представете си, че планирате обяд с група приятели. Понякога изборът на място, от което максимално много хора да са доволни, е трудна задача. Програмистите обичаме да си създаваме инструменти, които да ни помагат с решаването на трудни задачи. Това ще е целта и на нашето приложение за гласуване.

Ще го напишем от нулата с помощта на помощна библиотека за правене на уеб сайтове с Ruby, която се казва Sinatra. Sinatra е просто един от възможните инструменти, които можем да ползваме. Има и други, разбира се (например библиотеката Ruby on Rails). Sinatra е сравнително компактна и семпла библиотека, която въпреки простотата си има много възможности.

### Sinatra?! Аз очаквах Rails!

Може би някои от вас си казват – *"Чакай малко! Събитието се казва Rails Girls, а не Sinatra Girls."* Защо точно Sinatra, а не Ruby on Rails?

**Ruby on Rails vs. Sinatra**

Подобно на Sinatra, [Ruby on Rails](http://rubyonrails.org/) е библиотека, спомагаща създаването на динамични уебсайтове. Доста популярна е, определено по-популярна и по-употребявана от Sinatra. Но е и много по-сложна. Ако трябва да сравним Ruby on Rails и Sinatra, може да оприличим Ruby on Rails на автомобил, а Sinatra – на велосипед. Определено може да пренесете повече товар и да изминете повече път с автомобил. Велосипедът, обаче, е много по-евтин, прост и лесен за управление. При велосипеда всичко е открито – виждате добре как работи, кое задвижва колелата и ако ви падне веригата, вероятно ще може да си я оправите сами. При автомобила е доста по-сложно – двигателят е голям, тежък, пакетиран в една черна кутия, която трудно се разглобява и вътре се случват много неща. Да, можете да се научите да карате автомобил и без да разбирате как работи двигателят, но ако нещо се повреди, ще трябва да отидете на сервиз и ще ви излезе скъпо. Колата има повече възможности, но и много по-стръмна крива на научаване. А и не за всяко пътуване колата е най-добрият превоз. Понякога велосипед е напълно достатъчен.

Sinatra е нашият велосипед.

Ще ви научим да се придвижвате със собствените си сили и да разичтате максимално много на себе си. Когато овладеете тази стъпка, нищо не ви спира да се научите да шофирате и Ruby on Rails. Има безкрайно много материали по темата. Практиката ни с провеждане на Rails Girls събития ни показа, че много по-ефективно използваме краткото време на уъркшопа, като ви показваме Sinatra, вместо да се опитваме да ви обясним цялата магия, която Ruby on Rails прави за вас. Това е причината да четете това ръководство за Sinatra.

> **Инструктор:**
>
> Обяснете накратко какво е [Sinatra](http://www.sinatrarb.com), какво е "библиотека"/"framework" и защо съществуват софтуерните библиотеки изобщо.

## Инсталиране на Sinatra

Първо се налага да инсталираме библиотеката Sinatra, която ще използваме. Изпълнете следната команда в конзолата/комадния ред на Nitrous:

    gem install sinatra

> **Инструктор:**
>
> Припомнете и допълнете неща за работа с command line.

## Помощ (документация) за Sinatra

След като сме си инсталирали библиотеката, идва моментът да я използваме. По-долу ще ви даваме необходимия код, който да изпълните стъпка по стъпка, но ако някъде искате да се отклоните от примерите, или ударите на проблем, ще ви е необходима консултация с ръководството (документацията) на библиотеката Sinatra.

Тази документация се намира на адрес: <http://www.sinatrarb.com/intro.html>

Умението да се намира правилната документация и да се чете и извлича необходимата информация от нея е много важно и често подценявано. Ако търсите нещо там, четете внимателно, осмисляйте и питайте инструктора за това, което не ви е ясно. Не сканирайте диагонално, за да не изпуснете това, което ви трябва.

### Създайте своето първо Sinatra приложение

За да започнем нашето приложение, ще създадем една папка в Nitrous средата. Може да я кръстите както искате. Това може да стане както от дървото с папки и файлове, като кликнете с дясно копче върху "кореновата" папка `nitrous`, така и от терминала (конзолата), с командата `mkdir име_на_папката`. Попитайте инструктора си за обяснение за тези команди. Може да използвате и този [пищов с помощни команди](http://bit.ly/cheat-rails).

След като създадете папката, трябва да я направите "активна", като "влезете" в нея. В терминала това става с командата `cd име_на_папката` (съкращение от "change directory").

Когато сте в правилната директория, трябва да създадете един файл там. Отново може или от терминала, с `touch voter.rb`, или от графичния интерфейс на Nitrous, с дясно копче върху дървото с файлове. Файлът може да се казва `voter.rb` и да е със следното съдържание:

{% highlight ruby %}
require 'sinatra'

get '/' do
  'Здравей, гласоподавателю!'
end
{% endhighlight %}

В този Ruby файл ще се намира кодът (логиката) на вашето приложение. Можете да кръстите Ruby файла с каквото име желаете. `voter.rb` е просто примерно такова.

### Стартиране на приложението

От директорията, съдържаща създадения по-горе файл, изпълнете следната команда:

    ruby voter.rb -p 5000 -o 0.0.0.0

Ще видите да се появяват съобщения на екрана. След няколко секунди, приложението ви би трябвало да е заредило напълно и да е готово да обслужва потребители.

> **Инструктор:**
>
> Обяснете за това как се стартират Ruby програми и припомнете, че `ruby` е програма-интерпретатор. Говорете за команди и терминал, ако е необходимо. Обърнете внимание, че терминалът е "зает" с изпълнението на процес и това ще остане така, докато не спрем процеса ние, ръчно.
>
> Панелите в Nitrous могат да се разместват и да им се променя големината. Могат да се отварят и повече от един таб към терминала.

За да видите резултата, от менюто "Preview" изберете "Port 5000". В нов раздел на браузъра би трябвало да ви се отвори временен URL адрес, на който да видите текста "Здравей, гласоподавателю!". Ако там пише нещо друго, помолете инструктора си за помощ.

Забележка: Този URL, на който се зарежда вашето приложение, може да бъде зареден от всеки човек по света, но е временен и ще спре да е активен, ако си спрете приложението, или си затворите браузъра, излизайки от профила си в Nitrous.

За да правим промени по приложението, се налага да го спираме.

За да спрете приложението си, натиснете клавишната комбинация `ctrl-c`, когато фокусът ви е в терминала.

> **Инструктор:**
>
> Обяснете накратко, че кодът около `get` се грижи да посрещне заявките до `/` към нашето приложение и да върне отговор и че това, което пише вътре в низа (внимавайте с термините; *низ = текст между кавички*), е това, което ще се покаже в браузъра на потребителя.
>
> Споменете накратко за `HTTP`, `GET`, `POST` и как информацията пътува между браузъра и сървъра (request → response). По-долу ще стане въпрос отново за `GET` и `POST`.

### Добавяне на `index` страница

> **Инструктор:**
>
> Обяснете защо избираме точно името "index". Обяснете концепцията за шаблони (templates), още наричани "изгледи". Защо има нужда от това? Обяснете какво е ERB (embedded Ruby) и как става вмъкването на логика (Ruby) в изгледа и как HTML-ът се "динамизира". Споменете за това, че има и други начини за генериране на HTML от шаблони (например, [Slim](http://slim-lang.com/), [HAML](http://haml.info/) и други).

За да държим нещата подредени, ще направим папка, в която ще слагаме файловете на нашите "изгледи". Ще я кръстим "views" (логично, нали?)

Сложете следния код във файл, който се казва `index.erb` и се намира в папката `views`:

{% highlight erb %}
<!DOCTYPE html>
<html>
  <head>
    <meta charset='UTF-8' />
    <title>Машина за гласуване</title>
    <link href='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css' rel='stylesheet' />
  </head>
  <body class='container'>
    <p>Къде да обядваме?</p>
    <form action='cast' method='post'>
      <ul class='unstyled'>
        <% CHOICES.each do |place_id, place_name| %>
          <li>
            <label class='radio'>
              <input type='radio' name='vote' value='<%= place_id %>' id='vote_<%= place_id %>' />
              <%= place_name %>
            </label>
          </li>
        <% end %>
      </ul>
      <button type='submit' class='btn btn-primary'>Гласувай!</button>
    </form>
  </body>
</html>
{% endhighlight %}

И добавете следния код в началото на файла `voter.rb`:

{% highlight ruby %}
CHOICES = {
  'happy'        => 'Happy',
  'divaka'       => 'Дивака',
  'krivoto'      => 'Кривото',
  'ugo'          => 'Уго',
  'mr-pizza'     => 'Мистър Пица',
  'sun-moon'     => 'Слънце луна',
  'soul-kitchen' => 'Soul Kitchen',
}
{% endhighlight %}

Променете секцията с `get` действието така:

{% highlight ruby %}
get '/' do
  erb :index
end
{% endhighlight %}

Проверете дали всичко е наред, като пуснете отново вашето приложение с `ruby voter.rb -p 5000 -o 0.0.0.0`. Знаете ли, че в терминала имате история на последно изпълнените команди? Стрелките нагоре и надолу ви движат по тази история, когато в момента няма работеща команда там.

Очакваният резултат е списък с места за обяд, под формата на радио бутони и бутон "Гласувай!".

> **Инструктор:**
>
> Обяснете концепцията на типа данни "речник" (хеш). Обяснете защо HTML-ът, който сложихме в изгледа, се генерира от приложението ни (ако е нужно, покажете документацията на Sinatra, секцията за изгледи). Проверете в браузъра как изглежда вече генерираният HTML, за да се види разликата между шаблон и резултат.
>
> Обърнете внимание на цикъла с `each`. Обяснете откъде идват стойностите на променливите `place_id` и `place_name`.
>
> При необходимост, пуснете още един терминал в Nitrous и в него стартирайте `irb`, където демонстрирайте работа с хешове (речници) – създаване, извличане на стойност, добавяне и промяна на елементи, обхождане. Използвайте `puts` където е нужно. Оставете участничките да си поиграят и да осмислят концепциите за променливи.
>
> Обяснете разликата между ERB таговете `<% %>` (control) и `<%= %>` (output).
>
> *Опционално:* Ако е нужно, споменете, че `CHOICES` е константа и че това е необходимо, за да може да е с глобална видимост и да се "вижда" и в изгледа. Това може и да се пропусне.

### Предаване на променливи към изгледите

Променете `index.erb` файла в папката `views`, за да добавите `<h1>…</h1>` тагове:

{% highlight erb %}
  <body class='container'>
    <h1><%= @title %></h1>
    <p>Къде да обядваме?</p>
{% endhighlight %}

Променете и `get` действието по следния начин:

{% highlight ruby %}
get '/' do
  @title = 'Добре дошли в машината за гласуване!'
  erb :index
end
{% endhighlight %}

> **Инструктор:**
>
> Споменете накратко, че `@title` е (инстанционна) променлива (определен вид променлива) и че това е начин да се предават стойности (променливи) от "действието" (`get`) към шаблона на изгледа (`index.erb`). Формално, причината това да работи е, че в Sinatra и действието, и изгледите се оценяват в контекста на един и същи Ruby обект. Инстанционните променливи там могат да се създават динамично и не е нужно да са предварително декларирани. Достъп до недефинирана инстанционна променлива връща `nil`. Не е нужно да се говори за обекти и класове.

### Добавяне на възможност за изпращане на резултатите като POST

> **Инструктор:**
>
> Какво става, когато се гласува в момента? Обърнете внимание на 404 страницата по подразбиране на Sinatra и на информацията на нея. Защо имаме грешка 404?

Добавете следното във `voter.rb`:

{% highlight ruby %}
post '/cast' do
  @title = 'Благодарим за вашия глас!'
  @vote  = params['vote']
  erb :cast
end
{% endhighlight %}

Създайте нов файл в папката с изгледи `views`, който се казва `cast.erb`. В него сложете следния HTML и ERB код:

{% highlight erb %}
<!DOCTYPE html>
<html>
  <head>
    <meta charset='UTF-8' />
    <title>Машина за гласуване</title>
    <link href='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css' rel='stylesheet' />
  </head>
  <body class='container'>
    <h1><%= @title %></h1>
    <p>Вашият глас: <%= CHOICES[@vote] %></p>
    <p><a href='/results'>Вижте резултатите!</a></p>
  </body>
</html>
{% endhighlight %}

> **Инструктор:**
>
> Обяснете как работи `POST`. Откъде идват нещата в `params`? Как се съпоставят полетата във формуляра с нещата в `params`? Как можем да ги използваме? Защо изобщо има различни HTTP методи като GET (read-only) и POST (променя неща на сървъра)?

> **Бонус:**
>
> Добавете линк към страницата с резултатите и на началната страница, например до бутона за гласуване.

### Изнесете общия код в layout

Създайте файл `layout.erb` в папката с изгледите `views`. Сложете там следния код:

{% highlight erb %}
<!DOCTYPE html>
<html>
  <head>
    <meta charset='UTF-8' />
    <title>Машина за гласуване</title>
    <link href='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css' rel='stylesheet' />
  </head>
  <body class='container'>
    <h1><%= @title %></h1>
    <%= yield %>
  </body>
</html>
{% endhighlight %}

След това махнете вече дублиращите се общи части с HTML от другите два шаблона (`index.erb` и `cast.erb`).

> **Инструктор:**
>
> Обяснете защо се прави тази операция. Разяснете, че другите изгледи се вмъкват на мястото на `yield` и не е нужно да носят информация за общия layout.
>
> Обяснете защо кръстихме файла `layout` и защо нещата автоматично сработиха, без да декларираме някъде, че това е нашият layout (за справка - документацията; принцип - convention over configuration).

### Показване на резултатите

Добавете следния код във вашето приложение, във `voter.rb`:

{% highlight ruby %}
get '/results' do
  @votes = { 'happy' => 7, 'sun-moon' => 5 }
  erb :results
end
{% endhighlight %}

Създайте и нов шаблон за изглед в папката `views`, който кръстете `results.erb`:

{% highlight erb %}
<table class='table table-hover table-striped'>
  <% CHOICES.each do |place_id, place_name| %>
    <tr>
      <th><%= place_name %></th>
      <td><%= @votes[place_id] || 0 %>
      <td><%= '#' * (@votes[place_id] || 0) %></td>
    </tr>
  <% end %>
</table>
<p><a href='/'>Гласувайте още</a></p>
{% endhighlight %}

Стартирайте отново приложението с `ruby voter.rb -p 5000 -o 0.0.0.0` и проверете дали ще може да видите резултатите.

> **Инструктор:**
>
> Обяснете как работят таблиците в HTML. Обяснете как липсващите стойности от речника се броят като нула. Обяснете как така умножаваме текстов низ по число и какъв е резултатът. Припомнете `each` и речници. Обърнете внимание на алтернативното подреждане на елементи в речника (на един ред, вместо на много редове, както бяхме дефинирали речника за `CHOICES`).
>
> Помислете заедно защо в момента гласовете не се отразяват изобщо. Съберете идеи какво би трябвало да се промени.

### Отчитане на гласовете

Променете кода на `voter.rb` в действията `cast` и `results` така:

{% highlight ruby %}
post '/cast' do
  @title = 'Благодарим за вашия глас!'
  @vote  = params['vote']

  if votes[@vote]
    votes[@vote] = votes[@vote] + 1
  else
    votes[@vote] = 1
  end

  erb :cast
end

get '/results' do
  @votes = votes
  erb :results
end
{% endhighlight %}

Добавете и следния код преди или след `CHOICES = {...}` във `voter.rb`:

{% highlight ruby %}
votes = {}
{% endhighlight %}

Спрете и стартирайте отново приложението. Уверете се, че гласовете вече се отчитат правилно. Може да дадете адреса до вашето приложение и на някой друг, за да гласува и той.

> **Инструктор:**
>
> Може участничките да си разменят линковете на приложенията и да гласуват в чуждото приложение.
>
> Обяснете промените. Защо имаме нужда от този `if` в `cast`? Каква е ролята на локалната променлива `votes`?
>
> _(Блоковете в Ruby виждат локалните променливи, дефинирани в closure-a над тях, а действията в Sinatra реално са Ruby блокове. Докато Sinatra работи, процесът е жив и локалната променлива се пази между request-и, като in-memory DB. Инстанционните (тези, започващи с `@`) променливи в действията – не се пазят между request-и.)_
>
> Обърнете внимание на факта, че като се спре приложението, данните се губят.

### Трайно съхранение на гласовете с YAML::Store

Време е за нещо вълнуващо! Трайно съхранение на данни (persistence). Обикновено това става в СУБД (системи за управление на бази данни), накратко наричани "бази данни". Примери за някои популярни СУБД са PostgreSQL, MySQL, MS SQL, Oracle и други.

Ние няма да използваме цяла СУБД, а ще пазим данните от гласуването в обикновен текстов файл, който ще се обновява автоматично от нашето приложение. За целта ще ни послужи друга помощна библиотека, която е вградена в езика Ruby, но която трябва да заредим изрично.

Добавете следното в началото на `voter.rb`:

{% highlight ruby %}
require 'yaml/store'
{% endhighlight %}

Пак във `voter.rb`, заменете действията `post '/cast'` и `get '/results'` със следните версии:

{% highlight ruby %}
post '/cast' do
  @title = 'Благодарим за вашия глас!'
  @vote  = params['vote']
  @store = YAML::Store.new 'votes.yml'
  @store.transaction do
    if @store['votes'] == nil
      @store['votes'] = {}
    end

    if @store['votes'][@vote]
      @store['votes'][@vote] = @store['votes'][@vote] + 1
    else
      @store['votes'][@vote] = 1
    end
  end
  erb :cast
end

get '/results' do
  @title = 'Results so far:'
  @store = YAML::Store.new 'votes.yml'
  @votes = @store.transaction { @store['votes'] }
  erb :results
end
{% endhighlight %}

На този етап може да изтриете и реда `votes = {}` от `voter.rb`, който добавихме на предната стъпка.

Спрете и пуснете отново приложението. Гласувайте и наблюдавайте резултатите. Вижте дали се запазват, ако спрете и пуснете приложението отново. Разгледайте новопоявилия се и автоматично създаден и попълван файл `votes.yml`. Би трябвало да се намира в същата папка, където е `voter.rb`.

> **Инструктор:**
>
> Обяснете какво е YAML и как се грижи за обновяване на `votes.yml` файла и защо са ни `if`-овете.

## Играйте си с приложението

Опитайте да промените неща в приложението, за да видите какви ще са резултатите:

* Добавете допълнителна логика в изгледите.
* Препращайте веднага към резултатите след гласуване. **Инструктор:** Обяснете защо това е добра практика. Например, опитайте да презаредите страницата веднага след гласуване.
* Променете стилизирането на страницата по ваш вкус.
* Помислете има ли проблеми от гледна точка на сигурност с вашето приложение? Ако има такива, имате ли идеи за възможни решения, дори само на концептуално ниво?
* Поиграйте си с Ruby в `irb`. **Инструктор:** Говорете за изрази, стойности, оценки, викане на методи, параметри, типове данни и т.н.
